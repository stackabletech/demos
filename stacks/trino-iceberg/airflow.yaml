---
apiVersion: airflow.stackable.tech/v1alpha1
kind: AirflowCluster
metadata:
  name: airflow
spec:
  image:
    productVersion: 3.0.6
    pullPolicy: IfNotPresent
  clusterConfig:
    vectorAggregatorConfigMapName: vector-aggregator-discovery
    authorization:
      opa:
        configMapName: opa
        package: airflow
        cache:
          entryTimeToLive: 5s
          maxEntries: 10
    loadExamples: false
    credentialsSecret: airflow-credentials
    volumes:
      - name: airflow-dags
        configMap:
          name: airflow-dags
      - name: external-pvc
        persistentVolumeClaim:
          claimName: pvc-airflow
    volumeMounts:
      - name: airflow-dags
        mountPath: /stackable/airflow/dags/dbt_tc_agentur.py
        subPath: dbt_tc_agentur.py
      - name: airflow-dags
        mountPath: /stackable/airflow/dags/dbt_tc_person.py
        subPath: dbt_tc_person.py
      - name: airflow-dags
        mountPath: /stackable/airflow/dags/dbt_tc_schadenfall.py
        subPath: dbt_tc_schadenfall.py
      - name: airflow-dags
        mountPath: /stackable/airflow/dags/dbt_tc_schadennrsrv.py
        subPath: dbt_tc_schadennrsrv.py
      - name: external-pvc
        mountPath: /tmp
  webservers:
    roleConfig:
      listenerClass: external-stable
    config:
      logging:
        enableVectorAgent: true
      resources:
        cpu:
          min: "2"
          max: "3"
        memory:
          limit: 3Gi
    roleGroups:
      default:
        replicas: 1
  celeryExecutors:
    config:
      logging:
        enableVectorAgent: true
      resources:
        cpu:
          min: "2"
          max: "3"
        memory:
          limit: 4Gi
    roleGroups:
      default:
        replicas: 1
  # kubernetesExecutors:
  #   config: {}
  schedulers:
    config:
      logging:
        enableVectorAgent: true
    roleGroups:
      default:
        replicas: 1
  dagProcessors:
    config:
      logging:
        enableVectorAgent: true
    roleGroups:
      default:
        replicas: 1
  triggerers:
    config:
      logging:
        enableVectorAgent: true
    roleGroups:
      default:
        replicas: 1
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: airflow-dags
data:
  dbt_tc_agentur.py: |
    from airflow import DAG
    from airflow.providers.cncf.kubernetes.operators.pod import KubernetesPodOperator
    from kubernetes.client import models as k8s
    from kubernetes.client import V1EnvVar, V1EnvVarSource, V1SecretKeySelector

    tls_volume = k8s.V1Volume(
        name="server-tls-mount",
        ephemeral=k8s.V1EphemeralVolumeSource(
            volume_claim_template=k8s.V1PersistentVolumeClaimTemplate(
                metadata=k8s.V1ObjectMeta(
                    annotations={
                        "secrets.stackable.tech/class": "trino-tls",
                        "secrets.stackable.tech/scope": "pod,node"
                    }
                ),
                spec=k8s.V1PersistentVolumeClaimSpec(
                    access_modes=["ReadWriteOnce"],
                    resources=k8s.V1ResourceRequirements(
                        requests={"storage": "1"}
                    ),
                    storage_class_name="secrets.stackable.tech"
                )
            )
        )
    )

    tls_volume_mount = k8s.V1VolumeMount(
      name="server-tls-mount", mount_path="/dbt/trusted"
    )

    pod_security_context = k8s.V1PodSecurityContext(
        fs_group=1000
    )

    pvc_volume = k8s.V1Volume(
      name="external-pvc",
      persistent_volume_claim=k8s.V1PersistentVolumeClaimVolumeSource(claim_name="pvc-airflow"),
    )

    pvc_volume_mount = k8s.V1VolumeMount(
      name="external-pvc", mount_path="/tmp"
    )

    affinity = k8s.V1Affinity(
      pod_affinity = k8s.V1PodAffinity(
        required_during_scheduling_ignored_during_execution=[
          k8s.V1PodAffinityTerm(
            label_selector=k8s.V1LabelSelector(
              match_expressions=[
                  k8s.V1LabelSelectorRequirement(
                    key="app.kubernetes.io/instance",
                    operator="In",
                    values=["airflow"]
                  )
              ]
            ),
            topology_key="kubernetes.io/hostname"
          ),
        ]
      )
    )

    with DAG(
        dag_id="run_dbt_tc_agentur",
        schedule=None,
        tags=["Demo", "DBT"],
        catchup=False
    ) as dag:
      run_dbt = KubernetesPodOperator(
          image="oci.stackable.tech/sandbox/andrew/dbt-trino:0.0.1",
          image_pull_policy="IfNotPresent",
          cmds=["/bin/bash", "-x", "-euo", "pipefail", "-c"],
          arguments=["cd /tmp/tc_agentur && export DBT_PROFILES_DIR=/tmp/tc_agentur && dbt seed && dbt run && dbt test"],
          name="run-dbt-tc-agentur",
          task_id="dbt-seed-run-test",
          get_logs=True,
          volumes=[tls_volume, pvc_volume],
          volume_mounts=[tls_volume_mount, pvc_volume_mount],
          affinity=affinity,
          env_vars=[
              V1EnvVar(
                  name="TRINO_PASSWORD",
                  value_from=V1EnvVarSource(
                      secret_key_ref=V1SecretKeySelector(
                          name="demo-password",
                          key="password"
                      )
                  )
              ),
              V1EnvVar(name="TRINO_USER", value="admin"),
              V1EnvVar(name="TRINO_HOST", value="trino-coordinator-default-headless.default.svc.cluster.local"),
              V1EnvVar(name="TRINO_PORT", value="8443"),
              V1EnvVar(name="CERT_PATH", value="/dbt/trusted/ca.crt"),
          ],
          security_context=pod_security_context,
          startup_timeout_seconds=600
      )
      run_dbt

  dbt_tc_person.py: |
    from airflow import DAG
    from airflow.providers.cncf.kubernetes.operators.pod import KubernetesPodOperator
    from kubernetes.client import models as k8s
    from kubernetes.client import V1EnvVar, V1EnvVarSource, V1SecretKeySelector

    tls_volume = k8s.V1Volume(
        name="server-tls-mount",
        ephemeral=k8s.V1EphemeralVolumeSource(
            volume_claim_template=k8s.V1PersistentVolumeClaimTemplate(
                metadata=k8s.V1ObjectMeta(
                    annotations={
                        "secrets.stackable.tech/class": "trino-tls",
                        "secrets.stackable.tech/scope": "pod,node"
                    }
                ),
                spec=k8s.V1PersistentVolumeClaimSpec(
                    access_modes=["ReadWriteOnce"],
                    resources=k8s.V1ResourceRequirements(
                        requests={"storage": "1"}
                    ),
                    storage_class_name="secrets.stackable.tech"
                )
            )
        )
    )

    tls_volume_mount = k8s.V1VolumeMount(
      name="server-tls-mount", mount_path="/dbt/trusted"
    )

    pod_security_context = k8s.V1PodSecurityContext(
        fs_group=1000
    )

    pvc_volume = k8s.V1Volume(
      name="external-pvc",
      persistent_volume_claim=k8s.V1PersistentVolumeClaimVolumeSource(claim_name="pvc-airflow"),
    )

    pvc_volume_mount = k8s.V1VolumeMount(
      name="external-pvc", mount_path="/tmp"
    )

    affinity = k8s.V1Affinity(
      pod_affinity = k8s.V1PodAffinity(
        required_during_scheduling_ignored_during_execution=[
          k8s.V1PodAffinityTerm(
            label_selector=k8s.V1LabelSelector(
              match_expressions=[
                  k8s.V1LabelSelectorRequirement(
                    key="app.kubernetes.io/instance",
                    operator="In",
                    values=["airflow"]
                  )
              ]
            ),
            topology_key="kubernetes.io/hostname"
          ),
        ]
      )
    )

    with DAG(
        dag_id="run_dbt_tc_person",
        schedule=None,
        tags=["Demo", "DBT"],
        catchup=False
    ) as dag:
      run_dbt = KubernetesPodOperator(
          image="oci.stackable.tech/sandbox/andrew/dbt-trino:0.0.1",
          image_pull_policy="IfNotPresent",
          cmds=["/bin/bash", "-x", "-euo", "pipefail", "-c"],
          arguments=["cd /tmp/tc_person && export DBT_PROFILES_DIR=/tmp/tc_person && dbt run"],
          name="run-dbt-tc-person",
          task_id="dbt-run",
          get_logs=True,
          volumes=[tls_volume, pvc_volume],
          volume_mounts=[tls_volume_mount, pvc_volume_mount],
          affinity=affinity,
          env_vars=[
              V1EnvVar(
                  name="TRINO_PASSWORD",
                  value_from=V1EnvVarSource(
                      secret_key_ref=V1SecretKeySelector(
                          name="demo-password",
                          key="password"
                      )
                  )
              ),
              V1EnvVar(name="TRINO_USER", value="admin"),
              V1EnvVar(name="TRINO_HOST", value="trino-coordinator-default-headless.default.svc.cluster.local"),
              V1EnvVar(name="TRINO_PORT", value="8443"),
              V1EnvVar(name="CERT_PATH", value="/dbt/trusted/ca.crt"),
          ],
          security_context=pod_security_context,
          startup_timeout_seconds=600
      )
      run_dbt

  dbt_tc_schadenfall.py: |
    from airflow import DAG
    from airflow.providers.cncf.kubernetes.operators.pod import KubernetesPodOperator
    from kubernetes.client import models as k8s
    from kubernetes.client import V1EnvVar, V1EnvVarSource, V1SecretKeySelector

    tls_volume = k8s.V1Volume(
        name="server-tls-mount",
        ephemeral=k8s.V1EphemeralVolumeSource(
            volume_claim_template=k8s.V1PersistentVolumeClaimTemplate(
                metadata=k8s.V1ObjectMeta(
                    annotations={
                        "secrets.stackable.tech/class": "trino-tls",
                        "secrets.stackable.tech/scope": "pod,node"
                    }
                ),
                spec=k8s.V1PersistentVolumeClaimSpec(
                    access_modes=["ReadWriteOnce"],
                    resources=k8s.V1ResourceRequirements(
                        requests={"storage": "1"}
                    ),
                    storage_class_name="secrets.stackable.tech"
                )
            )
        )
    )

    tls_volume_mount = k8s.V1VolumeMount(
      name="server-tls-mount", mount_path="/dbt/trusted"
    )

    pod_security_context = k8s.V1PodSecurityContext(
        fs_group=1000
    )

    pvc_volume = k8s.V1Volume(
      name="external-pvc",
      persistent_volume_claim=k8s.V1PersistentVolumeClaimVolumeSource(claim_name="pvc-airflow"),
    )

    pvc_volume_mount = k8s.V1VolumeMount(
      name="external-pvc", mount_path="/tmp"
    )

    affinity = k8s.V1Affinity(
      pod_affinity = k8s.V1PodAffinity(
        required_during_scheduling_ignored_during_execution=[
          k8s.V1PodAffinityTerm(
            label_selector=k8s.V1LabelSelector(
              match_expressions=[
                  k8s.V1LabelSelectorRequirement(
                    key="app.kubernetes.io/instance",
                    operator="In",
                    values=["airflow"]
                  )
              ]
            ),
            topology_key="kubernetes.io/hostname"
          ),
        ]
      )
    )

    with DAG(
        dag_id="run_dbt_tc_schadenfall",
        schedule=None,
        tags=["Demo", "DBT"],
        catchup=False
    ) as dag:
      run_dbt = KubernetesPodOperator(
          image="oci.stackable.tech/sandbox/andrew/dbt-trino:0.0.1",
          image_pull_policy="IfNotPresent",
          cmds=["/bin/bash", "-x", "-euo", "pipefail", "-c"],
          arguments=["cd /tmp/tc_schadenfall && export DBT_PROFILES_DIR=/tmp/tc_schadenfall && dbt run"],
          name="run-dbt-tc-schadenfall",
          task_id="dbt-run",
          get_logs=True,
          volumes=[tls_volume, pvc_volume],
          volume_mounts=[tls_volume_mount, pvc_volume_mount],
          affinity=affinity,
          env_vars=[
              V1EnvVar(
                  name="TRINO_PASSWORD",
                  value_from=V1EnvVarSource(
                      secret_key_ref=V1SecretKeySelector(
                          name="demo-password",
                          key="password"
                      )
                  )
              ),
              V1EnvVar(name="TRINO_USER", value="admin"),
              V1EnvVar(name="TRINO_HOST", value="trino-coordinator-default-headless.default.svc.cluster.local"),
              V1EnvVar(name="TRINO_PORT", value="8443"),
              V1EnvVar(name="CERT_PATH", value="/dbt/trusted/ca.crt"),
          ],
          security_context=pod_security_context,
          startup_timeout_seconds=600
      )
      run_dbt

  dbt_tc_schadennrsrv.py: |
    from airflow import DAG
    from airflow.providers.cncf.kubernetes.operators.pod import KubernetesPodOperator
    from kubernetes.client import models as k8s
    from kubernetes.client import V1EnvVar, V1EnvVarSource, V1SecretKeySelector

    tls_volume = k8s.V1Volume(
        name="server-tls-mount",
        ephemeral=k8s.V1EphemeralVolumeSource(
            volume_claim_template=k8s.V1PersistentVolumeClaimTemplate(
                metadata=k8s.V1ObjectMeta(
                    annotations={
                        "secrets.stackable.tech/class": "trino-tls",
                        "secrets.stackable.tech/scope": "pod,node"
                    }
                ),
                spec=k8s.V1PersistentVolumeClaimSpec(
                    access_modes=["ReadWriteOnce"],
                    resources=k8s.V1ResourceRequirements(
                        requests={"storage": "1"}
                    ),
                    storage_class_name="secrets.stackable.tech"
                )
            )
        )
    )

    tls_volume_mount = k8s.V1VolumeMount(
      name="server-tls-mount", mount_path="/dbt/trusted"
    )

    pod_security_context = k8s.V1PodSecurityContext(
        fs_group=1000
    )

    pvc_volume = k8s.V1Volume(
      name="external-pvc",
      persistent_volume_claim=k8s.V1PersistentVolumeClaimVolumeSource(claim_name="pvc-airflow"),
    )

    pvc_volume_mount = k8s.V1VolumeMount(
      name="external-pvc", mount_path="/tmp"
    )

    affinity = k8s.V1Affinity(
      pod_affinity = k8s.V1PodAffinity(
        required_during_scheduling_ignored_during_execution=[
          k8s.V1PodAffinityTerm(
            label_selector=k8s.V1LabelSelector(
              match_expressions=[
                  k8s.V1LabelSelectorRequirement(
                    key="app.kubernetes.io/instance",
                    operator="In",
                    values=["airflow"]
                  )
              ]
            ),
            topology_key="kubernetes.io/hostname"
          ),
        ]
      )
    )

    with DAG(
        dag_id="run_dbt_tc_schadennrsrv",
        schedule=None,
        tags=["Demo", "DBT"],
        catchup=False
    ) as dag:
      run_dbt = KubernetesPodOperator(
          image="oci.stackable.tech/sandbox/andrew/dbt-trino:0.0.1",
          image_pull_policy="IfNotPresent",
          cmds=["/bin/bash", "-x", "-euo", "pipefail", "-c"],
          arguments=["cd /tmp/tc_schadennrsrv && export DBT_PROFILES_DIR=/tmp/tc_schadennrsrv && dbt run && dbt test"],
          name="run-dbt-tc-schadennrsrv",
          task_id="dbt-run-test",
          get_logs=True,
          volumes=[tls_volume, pvc_volume],
          volume_mounts=[tls_volume_mount, pvc_volume_mount],
          affinity=affinity,
          env_vars=[
              V1EnvVar(
                  name="TRINO_PASSWORD",
                  value_from=V1EnvVarSource(
                      secret_key_ref=V1SecretKeySelector(
                          name="demo-password",
                          key="password"
                      )
                  )
              ),
              V1EnvVar(name="TRINO_USER", value="admin"),
              V1EnvVar(name="TRINO_HOST", value="trino-coordinator-default-headless.default.svc.cluster.local"),
              V1EnvVar(name="TRINO_PORT", value="8443"),
              V1EnvVar(name="CERT_PATH", value="/dbt/trusted/ca.crt"),
          ],
          security_context=pod_security_context,
          startup_timeout_seconds=600
      )
      run_dbt
