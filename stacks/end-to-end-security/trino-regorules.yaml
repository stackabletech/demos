---
# {% raw %}
apiVersion: v1
kind: ConfigMap
metadata:
  name: trino-regorules
  labels:
    opa.stackable.tech/bundle: true
data:
  actual_permissions.rego: |
    package trino

    # This file contains functions to determine the actual permissions
    # defined in the Trino policies for the given user and requested
    # resource.
    #
    # For every resource, like catalog and table, the rules and functions
    # are structured as follows:
    #   * first_matching_resource_rule(parameters like table name) := ...
    #     Returns the first rule of the associated policies which match the
    #     identity and the given parameters
    #   * default resource_permission(_) := ...
    #     Default permission if no matching rule was found, e.g. "none".
    #   * resource_permission(parameters like table name) := ...
    #     Permission returned by the first_matching_resource_rule function

    identity := input.context.identity

    # METADATA
    # description: |
    #   Externally provided groups; These groups are added to the ones in
    #   input.context.identity.groups.
    #
    #   Example:
    #     package trino_policies
    #     extra_groups := data.stackable.opa.userinfo.v1.userInfoByUsername(input.context.identity.user).groups
    # scope: document
    default extra_groups := []

    extra_groups := data.trino_policies.extra_groups

    # Add an empty dummy group because the default pattern ".*" should match
    # even if the user is not a member of a group.
    groups := array.concat(
      array.concat(identity.groups, extra_groups),
      [""],
    )

    original_user_group_authorization_policies := [rule |
      some rule in policies.authorization
      match_original_user_group(rule)
    ]

    original_user_group_impersonation_policies := [rule |
      some rule in policies.impersonation
      match_original_user_group(rule)
    ]

    user_group_catalog_policies := [rule |
      some rule in policies.catalogs
      match_user_group(rule)
    ]

    user_group_catalog_session_property_policies := [rule |
      some rule in policies.catalog_session_properties
      match_user_group(rule)
    ]

    user_group_function_policies := [rule |
      some rule in policies.functions
      match_user_group(rule)
    ]

    user_group_procedure_policies := [rule |
      some rule in policies.procedures
      match_user_group(rule)
    ]

    user_group_query_policies := [rule |
      some rule in policies.queries
      match_user_group(rule)
    ]

    user_group_schema_policies := [rule |
      some rule in policies.schemas
      match_user_group(rule)
    ]

    user_group_system_information_policies := [rule |
      some rule in policies.system_information
      match_user_group(rule)
    ]

    user_group_system_session_property_policies := [rule |
      some rule in policies.system_session_properties
      match_user_group(rule)
    ]

    user_group_table_policies := [rule |
      some rule in policies.tables
      match_user_group(rule)
    ]

    default match_any_group(_) := false

    match_any_group(group_pattern) if {
      some group in groups
      match_entire(group_pattern, group)
    }

    default match_user_group(_) := false

    match_user_group(rule) if {
      user_pattern := object.get(rule, "user", ".*")
      match_entire(user_pattern, identity.user)

      group_pattern := object.get(rule, "group", ".*")
      match_any_group(group_pattern)
    }

    default match_original_user_group(_) := false

    match_original_user_group(rule) if {
      user_pattern := object.get(rule, "original_user", ".*")
      match_entire(user_pattern, identity.user)

      group_pattern := object.get(rule, "original_group", ".*")
      match_any_group(group_pattern)
    }

    first_matching_authorization_rule(grantee_name) := rule if {
      rules := [rule |
        some rule in original_user_group_authorization_policies

        new_user_pattern := object.get(rule, "new_user", ".*")

        match_entire(new_user_pattern, grantee_name)
      ]
      rule := object.union(
        {"allow": true},
        rules[0],
      )
    }

    default authorization_permission(_) := false

    authorization_permission(grantee_name) := first_matching_authorization_rule(grantee_name).allow

    first_matching_catalog_rule(catalog_name) := rule if {
      rules := [rule |
        some rule in user_group_catalog_policies

        catalog_pattern := object.get(rule, "catalog", ".*")

        match_entire(catalog_pattern, catalog_name)
      ]
      rule := rules[0]
    }

    catalog_access_map := {
      "all": {"all", "read-only"},
      "read-only": {"read-only"},
      "none": {"none"},
    }

    default catalog_access(_) := {"none"}

    catalog_access(catalog_name) := catalog_access_map[first_matching_catalog_rule(catalog_name).allow]

    first_matching_catalog_session_properties_rule(
      catalog_name,
      property_name,
    ) := rule if {
      rules := [rule |
        some rule in user_group_catalog_session_property_policies

        catalog_pattern := object.get(rule, "catalog", ".*")
        property_pattern := object.get(rule, "property", ".*")

        match_entire(catalog_pattern, catalog_name)
        match_entire(property_pattern, property_name)
      ]
      rule := rules[0]
    }

    default catalog_session_properties_access(_, _) := false

    catalog_session_properties_access(
      catalog_name,
      property_name,
    ) := first_matching_catalog_session_properties_rule(
      catalog_name,
      property_name,
    ).allow

    default catalog_visibility(_) := false

    catalog_visibility(catalog_name) if {
      "all" in catalog_access(catalog_name)
    }

    catalog_visibility(catalog_name) if {
      catalog_access(catalog_name) == {"read-only"}

      some rule in user_group_schema_policies

      catalog_pattern := object.get(rule, "catalog", ".*")

      match_entire(catalog_pattern, catalog_name)

      rule.owner == true
    }

    catalog_visibility(catalog_name) if {
      catalog_access(catalog_name) == {"read-only"}

      rules := array.concat(
        array.concat(
          user_group_table_policies,
          user_group_function_policies,
        ),
        user_group_procedure_policies,
      )

      some rule in rules

      catalog_pattern := object.get(rule, "catalog", ".*")

      match_entire(catalog_pattern, catalog_name)

      count(rule.privileges) != 0
    }

    catalog_visibility(catalog_name) if {
      catalog_access(catalog_name) == {"read-only"}

      some rule in user_group_catalog_session_property_policies

      catalog_pattern := object.get(rule, "catalog", ".*")

      match_entire(catalog_pattern, catalog_name)

      rule.allow == true
    }

    first_matching_function_rule(
      catalog_name,
      schema_name,
      function_name,
    ) := rule if {
      rules := [rule |
        some rule in user_group_function_policies

        catalog_pattern := object.get(rule, "catalog", ".*")
        schema_pattern := object.get(rule, "schema", ".*")
        function_pattern := object.get(rule, "function", ".*")

        match_entire(catalog_pattern, catalog_name)
        match_entire(schema_pattern, schema_name)
        match_entire(function_pattern, function_name)
      ]
      rule := rules[0]
    }

    default function_privileges(_, _, _) := set()

    function_privileges(
      catalog_name,
      schema_name,
      function_name,
    ) := {privilege |
      some privilege in first_matching_function_rule(
        catalog_name,
        schema_name,
        function_name,
      ).privileges
    }

    first_matching_impersonation_rule(user) := rule if {
      rules := [rule |
        some rule in original_user_group_impersonation_policies

        original_user_pattern := object.get(rule, "original_user", ".*")
        unsubstituted_new_user_pattern := object.get(rule, "new_user", ".*")

        matches := regex.find_all_string_submatch_n(
          original_user_pattern,
          identity.user, -1,
        )
        substitutes := {var: match |
          some i, match in matches[0]
          var := concat("", ["$", format_int(i, 10)])
        }

        # strings.replace_n replaces "$10" with "$1" followed by "0".
        # Therefore only nine capture groups are supported.
        new_user_pattern := strings.replace_n(
          substitutes,
          unsubstituted_new_user_pattern,
        )

        match_entire(new_user_pattern, user)
      ]
      rule := object.union(
        {"allow": true},
        rules[0],
      )
    }

    default impersonation_access(_) := false

    impersonation_access(user) if {
      user == identity.user
    }

    impersonation_access(user) := access if {
      user != identity.user
      access := first_matching_impersonation_rule(user).allow
    }

    # Matching the "function name" with the "procedure pattern" is intended.
    # The requested procedure name is contained in
    # `input.action.resource.function.functionName`. A rule applies if this
    # name matches the pattern in
    # `data.trino_policies.policies.procedures[_].procedure`.
    first_matching_procedure_rule(
      catalog_name,
      schema_name,
      function_name,
    ) := rule if {
      rules := [rule |
        some rule in user_group_procedure_policies

        catalog_pattern := object.get(rule, "catalog", ".*")
        schema_pattern := object.get(rule, "schema", ".*")
        procedure_pattern := object.get(rule, "procedure", ".*")

        match_entire(catalog_pattern, catalog_name)
        match_entire(schema_pattern, schema_name)
        match_entire(procedure_pattern, function_name)
      ]
      rule := rules[0]
    }

    default procedure_privileges(_, _, _) := set()

    procedure_privileges(
      catalog_name,
      schema_name,
      function_name,
    ) := {privilege |
      some privilege in first_matching_procedure_rule(
        catalog_name,
        schema_name,
        function_name,
      ).privileges
    }

    first_matching_query_rule := user_group_query_policies[0]

    default query_access := set()

    query_access := {access | some access in first_matching_query_rule.allow}

    first_matching_query_owned_by_rule(user) := rule if {
      rules := [rule |
        some rule in user_group_query_policies

        query_owner_pattern := object.get(rule, "queryOwner", ".*")

        match_entire(query_owner_pattern, user)
      ]
      rule := rules[0]
    }

    default query_owned_by_access(_) := set()

    query_owned_by_access(user) := {"kill", "view"} if {
      user == identity.user
    }

    query_owned_by_access(user) := access if {
      user != identity.user
      access := {access |
        some access in first_matching_query_owned_by_rule(user).allow
      }
    }

    first_matching_schema_rule(catalog_name, schema_name) := rule if {
      rules := [rule |
        some rule in user_group_schema_policies

        catalog_pattern := object.get(rule, "catalog", ".*")
        schema_pattern := object.get(rule, "schema", ".*")

        match_entire(catalog_pattern, catalog_name)
        match_entire(schema_pattern, schema_name)
      ]
      rule := rules[0]
    }

    default schema_owner(_, _) := false

    schema_owner(catalog_name, schema_name) := first_matching_schema_rule(
      catalog_name,
      schema_name,
    ).owner

    default schema_visibility(_, _) := false

    schema_visibility(catalog_name, schema_name) if {
      schema_owner(catalog_name, schema_name)
    }

    schema_visibility(_, "information_schema") := true

    schema_visibility(catalog_name, schema_name) if {
      schema_name != "information_schema"

      rules := array.concat(
        array.concat(
          user_group_table_policies,
          user_group_function_policies,
        ),
        user_group_procedure_policies,
      )

      some rule in rules

      catalog_pattern := object.get(rule, "catalog", ".*")
      match_entire(catalog_pattern, catalog_name)

      schema_pattern := object.get(rule, "schema", ".*")
      match_entire(schema_pattern, schema_name)

      count(rule.privileges) != 0
    }

    first_matching_table_rule(_, "information_schema", _) := {
      "schema": "information_schema",
      "privileges": [
        "DELETE",
        "GRANT_SELECT",
        "INSERT",
        "OWNERSHIP",
        "SELECT",
        "UPDATE",
      ],
      "filter": null,
      "filter_environment": {"user": null},
    }

    first_matching_table_rule(
      catalog_name,
      schema_name,
      table_name,
    ) := rule if {
      schema_name != "information_schema"
      rules := [rule |
        some rule in user_group_table_policies

        catalog_pattern := object.get(rule, "catalog", ".*")
        schema_pattern := object.get(rule, "schema", ".*")
        table_pattern := object.get(rule, "table", ".*")

        match_entire(catalog_pattern, catalog_name)
        match_entire(schema_pattern, schema_name)
        match_entire(table_pattern, table_name)
      ]
      rule := object.union(
        {
          "filter": null,
          "filter_environment": {"user": null},
        },
        rules[0],
      )
    }

    default column_constraints(_, _, _, _) := {
      "allow": true,
      "mask": null,
      "mask_environment": {"user": null},
    }

    column_constraints(_, "information_schema", _, _) := {
      "allow": true,
      "mask": null,
      "mask_environment": {"user": null},
    }

    column_constraints(
      catalog_name,
      schema_name,
      table_name,
      column_name,
    ) := constraints if {
      schema_name != "information_schema"

      rule := first_matching_table_rule(
        catalog_name,
        schema_name,
        table_name,
      )

      some column in rule.columns
      column.name == column_name

      constraints := object.union(
        {
          "allow": true,
          "mask": null,
          "mask_environment": {"user": null},
        },
        column,
      )
    }

    default table_privileges(_, _, _) := set()

    table_privileges(
      catalog_name,
      schema_name,
      table_name,
    ) := {privilege |
      some privilege in first_matching_table_rule(
        catalog_name,
        schema_name,
        table_name,
      ).privileges
    }

    default column_access(_, _, _, _) := false

    column_access(
      catalog_name,
      schema_name,
      table_name,
      column_name,
    ) := access if {
      table_privileges(
        catalog_name,
        schema_name,
        table_name,
      ) != set()

      column := column_constraints(
        catalog_name,
        schema_name,
        table_name,
        column_name,
      )

      access := column.allow
    }

    first_matching_system_information_rule := user_group_system_information_policies[0]

    default system_information_access := set()

    system_information_access := {access |
      some access in first_matching_system_information_rule.allow
    }

    first_matching_system_session_properties_rule(property_name) := rule if {
      rules := [rule |
        some rule in user_group_system_session_property_policies

        property_name_pattern := object.get(rule, "property", ".*")

        match_entire(property_name_pattern, property_name)
      ]
      rule := rules[0]
    }

    default system_session_properties_access(_) := false

    system_session_properties_access(property_name) := first_matching_system_session_properties_rule(property_name).allow
  policies.rego: |
    package trino

    # The final policies are a combination of policies offered by Stackable,
    # policies provided externally, and default policies.
    # Stackable's policies form the beginnings of the rule lists, i.e. they
    # are evaluated first and therefore cannot be overridden by the external
    # policies. The external policies then follow. For each rule list which
    # is not defined externally, default rules are appended.

    # METADATA
    # description: |
    #   The externally provided policies, see the file-based access control
    #   (https://trino.io/docs/current/security/file-system-access-control.html)
    #   for further documentation.
    #
    #   Example:
    #     package trino_policies
    #     policies := {
    #         "catalogs": [
    #             {
    #                 "user": "admin",
    #                 "allow": "all",
    #             },
    #         ],
    #         "schemas": [
    #             {
    #                 "user": "admin",
    #                 "owner": true,
    #             },
    #         ],
    #         "tables": [
    #             {
    #                 "user": "admin",
    #                 "privileges": [
    #                     "OWNERSHIP",
    #                     "GRANT_SELECT",
    #                 ],
    #             },
    #         ],
    #     }
    external_policies := data.trino_policies.policies

    stackable_policies := {"system_information": [{
      # Allow graceful shutdowns
      "user": "graceful-shutdown-user",
      "allow": [
        "read",
        "write",
      ],
    }]}

    policies := {
      "authorization": array.concat(
        object.get(stackable_policies, "authorization", []),
        object.get(
          external_policies,
          "authorization",
          [],
        ),
      ),
      "catalogs": array.concat(
        object.get(stackable_policies, "catalogs", []),
        object.get(
          external_policies,
          "catalogs",
          [{"allow": "all"}],
        ),
      ),
      "catalog_session_properties": array.concat(
        object.get(
          stackable_policies,
          "catalog_session_properties",
          [],
        ),
        object.get(
          external_policies,
          "catalog_session_properties",
          [{"allow": true}],
        ),
      ),
      "functions": array.concat(
        object.get(stackable_policies, "functions", []),
        object.get(
          external_policies,
          "functions",
          [{
            "catalog": "system",
            "schema": "builtin",
            "privileges": [
              "GRANT_EXECUTE",
              "EXECUTE",
            ],
          }],
        ),
      ),
      "impersonation": array.concat(
        object.get(stackable_policies, "impersonation", []),
        object.get(
          external_policies,
          "impersonation",
          [],
        ),
      ),
      "procedures": array.concat(
        object.get(stackable_policies, "procedures", []),
        object.get(
          external_policies,
          "procedures",
          [{
            "catalog": "system",
            "schema": "builtin",
            "privileges": [
              "GRANT_EXECUTE",
              "EXECUTE",
            ],
          }],
        ),
      ),
      "queries": array.concat(
        object.get(stackable_policies, "queries", []),
        object.get(
          external_policies,
          "queries",
          [{"allow": [
            "execute",
            "kill",
            "view",
          ]}],
        ),
      ),
      "schemas": array.concat(
        object.get(stackable_policies, "schemas", []),
        object.get(
          external_policies,
          "schemas",
          [{"owner": true}],
        ),
      ),
      "tables": array.concat(
        object.get(stackable_policies, "tables", []),
        object.get(
          external_policies,
          "tables",
          [{
            "privileges": [
              "DELETE",
              "GRANT_SELECT",
              "INSERT",
              "OWNERSHIP",
              "SELECT",
              "UPDATE",
            ],
            "filter": null,
            "filter_environment": {"user": null},
          }],
        ),
      ),
      "system_information": array.concat(
        object.get(stackable_policies, "system_information", []),
        object.get(
          external_policies,
          "system_information",
          [],
        ),
      ),
      "system_session_properties": array.concat(
        object.get(stackable_policies, "system_session_properties", []),
        object.get(
          external_policies,
          "system_session_properties",
          [{"allow": true}],
        ),
      ),
    }
  requested_permissions.rego: |
    package trino

    # This file contains the requested_permissions rule which returns a set
    # of required permissions for the given operation including the
    # requested resource. Operations with the same set of required
    # permissions are grouped together.
    # The defined permissions should be identical to the ones implemented
    # for the file-based access control
    # (https://trino.io/docs/current/security/file-system-access-control.html).

    requested_permissions(action) := permissions if {
      action.operation == "AccessCatalog"
      permissions := {{
        "resource": "catalog",
        "catalogName": action.resource.catalog.name,
        "allow": "read-only",
      }}
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "CreateSchema",
        "DropSchema",
        "ShowCreateSchema",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.schema.catalogName,
          "allow": "all",
        },
        {
          "resource": "schema",
          "catalogName": action.resource.schema.catalogName,
          "schemaName": action.resource.schema.schemaName,
          "owner": true,
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "AddColumn",
        "AlterColumn",
        "CreateMaterializedView",
        "CreateTable",
        "CreateView",
        "CreateViewWithSelectFromColumns",
        "DropColumn",
        "DropMaterializedView",
        "DropTable",
        "DropView",
        "RenameColumn",
        "SetColumnComment",
        "SetMaterializedViewProperties",
        "SetTableComment",
        "SetTableProperties",
        "SetViewComment",
        "ShowCreateTable",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "all",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"allOf": {"OWNERSHIP"}},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "RefreshMaterializedView",
        "UpdateTableColumns",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "all",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"allOf": {"UPDATE"}},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "DeleteFromTable",
        "TruncateTable",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "all",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"allOf": {"DELETE"}},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "ExecuteQuery"
      permissions := {{
        "resource": "query",
        "allow": {"execute"},
      }}
    }

    requested_permissions(action) := permissions if {
      action.operation == "ExecuteTableProcedure"

      # Executing table procedures is always allowed
      permissions := set()
    }

    requested_permissions(action) := permissions if {
      action.operation == "FilterColumns"
      permissions := {
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"anyOf": {
            "SELECT",
            "INSERT",
            "DELETE",
            "UPDATE",
            "OWNERSHIP",
            "GRANT_SELECT",
          }},
        },
        {
          "resource": "column",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "columnName": action.resource.table.columnName,
          "allow": true,
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "KillQueryOwnedBy"
      permissions := {{
        "resource": "query_owned_by",
        "user": action.resource.user.user,
        "groups": action.resource.user.groups,
        "allow": {"kill"},
      }}
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "FilterViewQueryOwnedBy",
        "ViewQueryOwnedBy",
      }
      permissions := {{
        "resource": "query_owned_by",
        "user": action.resource.user.user,
        "groups": action.resource.user.groups,
        "allow": {"view"},
      }}
    }

    requested_permissions(action) := permissions if {
      action.operation == "FilterTables"
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "read-only",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"anyOf": {
            "SELECT",
            "INSERT",
            "DELETE",
            "UPDATE",
            "OWNERSHIP",
            "GRANT_SELECT",
          }},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "CreateFunction",
        "DropFunction",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.function.catalogName,
          "allow": "all",
        },
        {
          "resource": "function",
          "catalogName": action.resource.function.catalogName,
          "schemaName": action.resource.function.schemaName,
          "functionName": action.resource.function.functionName,
          "privileges": {"OWNERSHIP"},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "ExecuteFunction",
        "FilterFunctions",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.function.catalogName,
          "allow": "read-only",
        },
        {
          "resource": "function",
          "catalogName": action.resource.function.catalogName,
          "schemaName": action.resource.function.schemaName,
          "functionName": action.resource.function.functionName,
          "privileges": {"EXECUTE"},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "ExecuteProcedure"
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.function.catalogName,
          "allow": "read-only",
        },
        {
          "resource": "procedure",
          "catalogName": action.resource.function.catalogName,
          "schemaName": action.resource.function.schemaName,
          "functionName": action.resource.function.functionName,
          "privileges": {"EXECUTE"},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "CreateViewWithExecuteFunction"
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.function.catalogName,
          "allow": "read-only",
        },
        {
          "resource": "function",
          "catalogName": action.resource.function.catalogName,
          "schemaName": action.resource.function.schemaName,
          "functionName": action.resource.function.functionName,
          "privileges": {"GRANT_EXECUTE"},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "ImpersonateUser"
      permissions := {{
        "resource": "impersonation",
        "user": action.resource.user.user,
        "allow": true,
      }}
    }

    requested_permissions(action) := permissions if {
      action.operation == "InsertIntoTable"
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "all",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"allOf": {"INSERT"}},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "ReadSystemInformation"
      permissions := {{
        "resource": "system_information",
        "allow": {"read"},
      }}
    }

    requested_permissions(action) := permissions if {
      action.operation == "RenameSchema"
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.schema.catalogName,
          "allow": "all",
        },
        {
          "resource": "catalog",
          "catalogName": action.targetResource.schema.catalogName,
          "allow": "all",
        },
        {
          "resource": "schema",
          "catalogName": action.resource.schema.catalogName,
          "schemaName": action.resource.schema.schemaName,
          "owner": true,
        },
        {
          "resource": "schema",
          "catalogName": action.targetResource.schema.catalogName,
          "schemaName": action.targetResource.schema.schemaName,
          "owner": true,
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "RenameMaterializedView",
        "RenameTable",
        "RenameView",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "all",
        },
        {
          "resource": "catalog",
          "catalogName": action.targetResource.table.catalogName,
          "allow": "all",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"allOf": {"OWNERSHIP"}},
        },
        {
          "resource": "table",
          "catalogName": action.targetResource.table.catalogName,
          "schemaName": action.targetResource.table.schemaName,
          "tableName": action.targetResource.table.tableName,
          "privileges": {"allOf": {"OWNERSHIP"}},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "SelectFromColumns"
      column_permissions := {
      {
        "resource": "column",
        "catalogName": action.resource.table.catalogName,
        "schemaName": action.resource.table.schemaName,
        "tableName": action.resource.table.tableName,
        "columnName": column_name,
        "allow": true,
      } |
        some column_name in action.resource.table.columns
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "read-only",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"allOf": {"SELECT"}},
        },
      } | column_permissions
    }

    requested_permissions(action) := permissions if {
      action.operation == "SetSchemaAuthorization"
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.schema.catalogName,
          "allow": "all",
        },
        {
          "resource": "schema",
          "catalogName": action.resource.schema.catalogName,
          "schemaName": action.resource.schema.schemaName,
          "owner": true,
        },
        {
          "resource": "authorization",
          "granteeName": action.grantee.name,
          "granteeType": action.grantee.type,
          "allow": true,
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "SetTableAuthorization",
        "SetViewAuthorization",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "all",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"allOf": {"OWNERSHIP"}},
        },
        {
          "resource": "authorization",
          "granteeName": action.grantee.name,
          "granteeType": action.grantee.type,
          "allow": true,
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "ShowColumns"
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.table.catalogName,
          "allow": "read-only",
        },
        {
          "resource": "table",
          "catalogName": action.resource.table.catalogName,
          "schemaName": action.resource.table.schemaName,
          "tableName": action.resource.table.tableName,
          "privileges": {"anyOf": {
            "SELECT",
            "INSERT",
            "DELETE",
            "UPDATE",
            "OWNERSHIP",
            "GRANT_SELECT",
          }},
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "FilterCatalogs",
        "ShowSchemas",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.catalog.name,
          "allow": "read-only",
        },
        {
          "resource": "catalog_visibility",
          "catalogName": action.resource.catalog.name,
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation in {
        "FilterSchemas",
        "ShowFunctions",
        "ShowTables",
      }
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.schema.catalogName,
          "allow": "read-only",
        },
        {
          "resource": "schema_visibility",
          "catalogName": action.resource.schema.catalogName,
          "schemaName": action.resource.schema.schemaName,
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "SetCatalogSessionProperty"
      permissions := {
        {
          "resource": "catalog",
          "catalogName": action.resource.catalogSessionProperty.catalogName,
          "allow": "read-only",
        },
        {
          "resource": "catalog_session_properties",
          "catalogName": action.resource.catalogSessionProperty.catalogName,
          "propertyName": action.resource.catalogSessionProperty.propertyName,
          "allow": true,
        },
      }
    }

    requested_permissions(action) := permissions if {
      action.operation == "SetSystemSessionProperty"
      permissions := {{
        "resource": "system_session_properties",
        "propertyName": action.resource.systemSessionProperty.name,
        "allow": true,
      }}
    }

    requested_permissions(action) := permissions if {
      action.operation == "WriteSystemInformation"
      permissions := {{
        "resource": "system_information",
        "allow": {"write"},
      }}
    }

    requested_authorization_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "authorization"
    ]

    requested_catalog_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "catalog"
    ]

    requested_catalog_session_properties_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "catalog_session_properties"
    ]

    requested_catalog_visibility_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "catalog_visibility"
    ]

    requested_column_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "column"
    ]

    requested_function_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "function"
    ]

    requested_impersonation_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "impersonation"
    ]

    requested_procedure_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "procedure"
    ]

    requested_query_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "query"
    ]

    requested_query_owned_by_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "query_owned_by"
    ]

    requested_schema_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "schema"
    ]

    requested_schema_visibility_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "schema_visibility"
    ]

    requested_table_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "table"
    ]

    requested_system_information_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "system_information"
    ]

    requested_system_session_properties_permissions(action) := [permission |
      some permission in requested_permissions(action)
      permission.resource == "system_session_properties"
    ]

    requested_column_mask(action) := request if {
      action.operation == "GetColumnMask"
      request := {
        "catalogName": action.resource.column.catalogName,
        "schemaName": action.resource.column.schemaName,
        "tableName": action.resource.column.tableName,
        "columnName": action.resource.column.columnName,
      }
    }

    requested_row_filters(action) := request if {
      action.operation == "GetRowFilters"
      request := {
        "catalogName": action.resource.table.catalogName,
        "schemaName": action.resource.table.schemaName,
        "tableName": action.resource.table.tableName,
      }
    }
  verification.rego: |
    # METADATA
    # description: |
    #   The file verification.rego contains the entry points which are
    #   queried from outside. These are:
    #     - allow
    #     - batch
    #     - columnMask
    #     - rowFilters
    #   These rules use the rules and functions in requested_permission.rego
    #   and actual_permissions.rego to calculate the result.
    #
    #   The file requested_permissions.rego contains the
    #   requested_permissions rule which returns a set of required
    #   permissions for the given operation including the requested
    #   resource.
    #
    #   The file actual_permissions.rego contains functions to determine the
    #   actual permissions defined in the Trino policies for the given user
    #   and requested resource.
    # schemas:
    #   - input: schema.input
    #   - data.trino_policies.policies: schema.policies
    package trino

    # METADATA
    # description: |
    #   Entry point for OPA policies, configured in the Trino property
    #   `opa.policy.uri`.
    #
    #   The input has the following form:
    #
    #   {
    #     "action": {
    #       "operation": "OperationName",
    #       "resource": {
    #         ...
    #       },
    #     },
    #     "context": {
    #       "identity": {
    #         "groups": ["group1", ...],
    #         "user": "username",
    #       },
    #       "softwareStack": {"trinoVersion": "455"},
    #     }
    #   }
    #
    #   The result is a boolean value indicating if the operation is allowed
    #   or not on the given resource by the given user.
    #
    #   The allow rule compares the permissions configured in the
    #   requested_permissions rule for the given operation with the Trino
    #   policies given in data.trino_policies.policies for the given
    #   identity.
    #
    #   For instance, if the user wants to insert data into a table then the
    #   requested_permissions rule requires for the "InsertIntoTable"
    #   operation "all" access to the catalog and the "INSERT" privilege on
    #   the table. The functions catalog_access and table_privileges defined
    #   in actual_permissions.rego are called to check if these requirements
    #   are fulfilled by the policies for the given user.
    # entrypoint: true
    default allow := false

    allow := allowWith(input.action)

    allowWith(action) if {
      # Fail if the requested permissions for the given operation are not
      # implemented yet
      #
      # The following operations are intentionally not supported:
      # - CreateCatalog
      # - DropCatalog
      requested_permissions(action)

      every requested_permission in requested_authorization_permissions(action) {
        permission := authorization_permission(requested_permission.granteeName)
        requested_permission.allow == permission
      }
      every requested_permission in requested_catalog_permissions(action) {
        access := catalog_access(requested_permission.catalogName)
        requested_permission.allow in access
      }
      every requested_permission in requested_catalog_session_properties_permissions(action) {
        access := catalog_session_properties_access(
          requested_permission.catalogName,
          requested_permission.propertyName,
        )
        requested_permission.allow == access
      }
      every requested_permission in requested_catalog_visibility_permissions(action) {
        catalog_visibility(requested_permission.catalogName)
      }
      every requested_permission in requested_column_permissions(action) {
        access := column_access(
          requested_permission.catalogName,
          requested_permission.schemaName,
          requested_permission.tableName,
          requested_permission.columnName,
        )
        requested_permission.allow == access
      }
      every requested_permission in requested_function_permissions(action) {
        privileges := function_privileges(
          requested_permission.catalogName,
          requested_permission.schemaName,
          requested_permission.functionName,
        )
        object.subset(privileges, requested_permission.privileges)
      }
      every requested_permission in requested_impersonation_permissions(action) {
        access := impersonation_access(requested_permission.user)
        requested_permission.allow == access
      }
      every requested_permission in requested_procedure_permissions(action) {
        privileges := procedure_privileges(
          requested_permission.catalogName,
          requested_permission.schemaName,
          requested_permission.functionName,
        )
        object.subset(privileges, requested_permission.privileges)
      }
      every requested_permission in requested_query_permissions(action) {
        object.subset(query_access, requested_permission.allow)
      }
      every requested_permission in requested_query_owned_by_permissions(action) {
        object.subset(
          query_owned_by_access(requested_permission.user),
          requested_permission.allow,
        )
      }
      every requested_permission in requested_schema_permissions(action) {
        schema_owner(
          requested_permission.catalogName,
          requested_permission.schemaName,
        ) == requested_permission.owner
      }
      every requested_permission in requested_schema_visibility_permissions(action) {
        schema_visibility(
          requested_permission.catalogName,
          requested_permission.schemaName,
        )
      }
      every requested_permission in requested_table_permissions(action) {
        privileges := table_privileges(
          requested_permission.catalogName,
          requested_permission.schemaName,
          requested_permission.tableName,
        )
        all_of_requested := object.get(
          requested_permission.privileges,
          "allOf",
          set(),
        )
        any_of_requested := object.get(
          requested_permission.privileges,
          "anyOf",
          privileges,
        )
        object.subset(privileges, all_of_requested)
        privileges & any_of_requested != set()
      }
      every requested_permission in requested_system_information_permissions(action) {
        object.subset(
          system_information_access,
          requested_permission.allow,
        )
      }
      every requested_permission in requested_system_session_properties_permissions(action) {
        access := system_session_properties_access(requested_permission.propertyName)
        requested_permission.allow == access
      }
    }

    # METADATA
    # description: |
    #   Entry point for batch OPA policies, configured in the Trino property
    #   `opa.policy.batched-uri`.
    #
    #   The input has the following form:
    #
    #   {
    #     "action": {
    #       "operation": "FilterOperationName",
    #       "filterResources": [
    #         {"resource1": ...},
    #         {"resource2": ...},
    #         ...
    #       ],
    #     },
    #     "context": {
    #       "identity": {
    #         "groups": ["group1", ...],
    #         "user": "username",
    #       },
    #       "softwareStack": {"trinoVersion": "455"},
    #     }
    #   }
    #
    #   The result is a list of indices which are allowed.
    #
    #   The batch rule just calls the allow rule for each resource.
    #
    #   FilterColumns is different to the other filter operations because
    #   "filterResources" contains exactly one table with a list of
    #   columns and the expected result is the list of allowed column
    #   indices and not of allowed tables.
    # entrypoint: true
    batch contains index if {
      input.action.operation != "FilterColumns"

      some index, resource in input.action.filterResources

      action := object.union(object.remove(input.action, {"filterResources"}), {"resource": resource})

      allowWith(action)
    }

    batch contains index if {
      input.action.operation == "FilterColumns"

      table := input.action.filterResources[0].table
      some index, column_name in table.columns

      action := object.union(object.remove(input.action, {"filterResources"}), {"resource": {"table": {
        "catalogName": table.catalogName,
        "schemaName": table.schemaName,
        "tableName": table.tableName,
        "columnName": column_name,
      }}})

      allowWith(action)
    }

    # METADATA
    # description: |
    #   Entry point for fetching column masks, configured in the Trino
    #   property `opa.policy.column-masking-uri`.
    #
    #   The input has the following form:
    #
    #   {
    #     "action": {
    #       "operation": "GetColumnMask",
    #       "resource": {
    #         "column": {
    #           "catalogName": "catalog",
    #           "schemaName": "schema",
    #           "tableName": "table",
    #           "columnName": "column",
    #         },
    #       },
    #     },
    #     "context": {
    #       "identity": {
    #         "groups": ["group1", ...],
    #         "user": "username",
    #       },
    #       "softwareStack": {"trinoVersion": "455"},
    #     }
    #   }
    #
    #   The result is an object containing the mask expression and the
    #   identity for the mask evaluation.
    #
    #   The columnMask rule queries the column constraints in the Trino
    #   policies and returns the expression if any is set. A column mask
    #   is an SQL expression, e.g. "'XXX-XX-' + substring(credit_card, -4)".
    # entrypoint: true
    columnMask := column_mask if {
      request := requested_column_mask(input.action)

      column := column_constraints(
        request.catalogName,
        request.schemaName,
        request.tableName,
        request.columnName,
      )

      is_string(column.mask)
      is_string(column.mask_environment.user)

      column_mask := {
        "expression": column.mask,
        "identity": column.mask_environment.user,
      }
    }

    columnMask := column_mask if {
      request := requested_column_mask(input.action)

      column := column_constraints(
        request.catalogName,
        request.schemaName,
        request.tableName,
        request.columnName,
      )

      is_string(column.mask)
      is_null(column.mask_environment.user)

      column_mask := {"expression": column.mask}
    }

    # METADATA
    # description: |
    #   Entry point for fetching row filters, configured in the Trino
    #   property `opa.policy.row-filters-uri`.
    #
    #   The input has the following form:
    #
    #   {
    #     "action": {
    #       "operation": "GetRowFilters",
    #       "resource": {
    #         "table": {
    #           "catalogName": "catalog",
    #           "schemaName": "schema",
    #           "tableName": "table",
    #         },
    #       },
    #     },
    #     "context": {
    #       "identity": {
    #         "groups": ["group1", ...],
    #         "user": "username",
    #       },
    #       "softwareStack": {"trinoVersion": "455"},
    #     }
    #   }
    #
    #   The result is a list containing one object which consists of the
    #   row filter expression and the identity for the filter evaluation.
    #
    #   The rowFilters rule queries the column constraints in the Trino
    #   policies and returns the expression if any is set. A row filter is
    #   an SQL condition, e.g. "user = current_user".
    # entrypoint: true
    rowFilters contains row_filter if {
      request := requested_row_filters(input.action)

      rule := first_matching_table_rule(
        request.catalogName,
        request.schemaName,
        request.tableName,
      )

      is_string(rule.filter)
      is_string(rule.filter_environment.user)

      row_filter := {
        "expression": rule.filter,
        "identity": rule.filter_environment.user,
      }
    }

    rowFilters contains row_filter if {
      request := requested_row_filters(input.action)

      rule := first_matching_table_rule(
        request.catalogName,
        request.schemaName,
        request.tableName,
      )

      is_string(rule.filter)
      is_null(rule.filter_environment.user)

      row_filter := {"expression": rule.filter}
    }
  util.rego: |
    package trino

    # METADATA
    # description: |
    #   Matches the entire string against a regular expression.
    #
    #   pattern (string)  regular expression
    #   value (string)    value to match against pattern
    #
    #   Returns:
    #     result (boolean)
    # scope: document
    match_entire(`.*`, value)

    match_entire(pattern, value) if {
      pattern != `.*`

      # Add the anchors ^ and $
      pattern_with_anchors := concat("", ["^", pattern, "$"])

      regex.match(pattern_with_anchors, value)
    }
# {% endraw %}
